#!/usr/bin/env perl6
use v6;

my $CONFIGDIR = "%*ENV<HOME>/.neutro";
my $INSTALLDIR = "%*ENV<HOME>/.perl6";
my $TMPDIR = "$CONFIGDIR/work";
my %modules;

# check if modules list is present, update it otherwise
sub checklist {
	unless $CONFIGDIR.IO ~~ :d {
		mkdirp $CONFIGDIR;
	}
	unless "$CONFIGDIR/modules.list".IO ~~ :f {
		updatedb;
	}
	my $list = slurp "$CONFIGDIR/modules.list";
	my @lines = $list.split("\n");
	for @lines -> $line {
		next if $line ~~ /^\#/;
		my ($name, $protoname, $url) = $line.split: ' ';
		%modules{$name}<protoname> = $protoname;
		%modules{$name}<url> = $url;
	}
}

sub cleanup {
	run "rm -rf $TMPDIR";
}

sub crap (Str $msg) {
	notice $msg;
	exit 1;
}

sub fetch (Str $name) {
	my $res;
	chdir $CONFIGDIR;
	notice "Cloning $name";
	$res = run "git clone %modules{$name}<url> work";
	crap "Failed cloning the repo!" if $res;
	chdir 'work';
}

# translate proto module name to our module name (if needed)
sub getname (Str $name) {
	return $name if %modules.exists($name);
	for %modules.kv -> $module, $data {
		if $data<protoname> eq $name {
			return $module;
		}
	}
	return;
}

sub install (Str $module) {
	my $res;
	my $name = getname $module or crap "Unknown module '$module'";
	fetch $name;
	installdeps $name;
	if 'Configure.pl'.IO ~~ :f {
		$res = run 'perl6 Configure.pl';
		crap 'Configure.pl has failed' if $res;
	}
	unless 'Makefile'.IO ~~ :f or 'makefile'.IO ~~ :f {
		notice 'Creating the makefile';
		if run 'which ufo' {
			ufo-inline;
		} else {
			run 'ufo';
		}
	}
	notice "Building $name";
	$res = run 'make';
	crap 'make failed' if $res;
	# testing
	if 't'.IO ~~ :d {
		notice "Testing $name";
		$res = run 'make test';
		crap 'tests failed' if $res;
	} else {
		notice "No tests for $name";
	}
	notice "Installing $name";
	$res = run 'make install';
	crap 'make install failed' if $res;
	notice "Succesfully installed $name";
	cleanup;
}

sub installdeps (Str $name) {
	my $dir = cwd;
	if 'deps.proto'.IO ~~ :f {
		my $depfile = slurp 'deps.proto';
		my @deps = $depfile.split: "\n";
		for @deps -> $dep {
			next if $dep ~~ /^\#/;
			next if $dep eq '';
			unless isinstalled $dep {
				my $realdep = getname $dep
							or crap "No such module: $dep ($name dependency)";
				notice "Found $realdep as a $name dependency, installing";
				install $dep;
				notice "$realdep installed, now back into $name";
			}
		}
	}
	chdir $dir;
}

sub isinstalled (Str $module) {
	eval "use $module";
	return $! ?? False !! True;
}

sub listmodules {
	for %modules.keys.sort { .say }
}

sub mkdirp (Str $what) {
	my @parts = $what.split('/').grep: { $_ };
	my $path;
	for @parts -> $dir {
		$path ~= "/$dir";
		next if $path.IO ~~ :e;
		mkdir $path;
	}
}

sub notice (Str $what) {
	say "\e[1m==> ", $what, "\e[0m";
}

sub updatedb {
	notice 'Updating modules database';
	chdir $CONFIGDIR;
	unlink 'modules.list' if 'modules.list'.IO ~~ :e;
	# downloading; TODO: Portable solution
	run 'wget http://github.com/tadzik/neutro/raw/master/modules.list';
	notice 'Fresh modules.list fetched';
}

sub MAIN ($command, $param?) {
	checklist;
	given $command {
		when 'i' {
			unless $param.defined {
				crap "i requires a parameter -- a module name";
			}
			install $param;
		}
		when 'l' {
			listmodules;
		}
		when 'u' {
			updatedb;
		}
		default {
			USAGE;
		}
	}
}

sub USAGE {
	say "Usage: neutro <command> [parameter]";
	say "Available commands (with example usage):
	neutro i Acme::Meow -- install Acme::Meow
	neutro l            -- list available modules
	neutro u            -- update the modules database
";
}

# Inlined ufo below

#!/usr/bin/env perl6

# This is the template for the entire generated Makefile.
sub makefile_template() {
    return q{
.PHONY: all build test install clean distclean purge

UFO := $(shell which ufo)
PERL6 = $binary
PREFIX = ~/.perl6
BLIB = blib
P6LIB = $(PWD)/$(BLIB)/lib:$(PWD)/lib:$(PERL6LIB)

$sources
$scripts
PIRS = $(patsubst %.pm6,%.pir,$(SOURCES:%.pm=%.pir))
BLIB_PIRS = $(PIRS:%=$(BLIB)/%)
INSTALL_SOURCES = $(SOURCES:%=$(PREFIX)/%)
INSTALL_SCRIPTS = $(SCRIPTS:%=$(PREFIX)/%)
INSTALL_PIRS = $(PIRS:%=$(PREFIX)/%)
TESTS = $(shell if [ -d 't' ]; then find t -name '*.t'; fi)

all:: build

Makefile:: $(UFO)
	ufo

build:: $(BLIB_PIRS)

$(BLIB)/%.pir:: %.pm
	mkdir -p `dirname '$@'`
	env PERL6LIB=$(P6LIB) $(PERL6) --target=pir --output=$@ $<

$(BLIB)/%.pir:: %.pm6
	mkdir -p `dirname '$@'`
	env PERL6LIB=$(P6LIB) $(PERL6) --target=pir --output=$@ $<

test:: build
	env PERL6LIB=$(P6LIB) prove -e '$(PERL6)' -r --nocolor t/

$(TESTS):: build
	env PERL6LIB=$(P6LIB) prove -v -e '$(PERL6)' -r --nocolor $@

install:: build $(INSTALL_SOURCES) $(INSTALL_PIRS) $(INSTALL_SCRIPTS)

$(PREFIX)/%.pm:: %.pm
	mkdir -p `dirname '$@'`
	install $< $@

$(PREFIX)/%.pm6:: %.pm6
	mkdir -p `dirname '$@'`
	install $< $@

$(PREFIX)/%.pir:: blib/%.pir
	mkdir -p `dirname '$@'`
	install $< $@

$(PREFIX)/bin/%:: bin/%
	mkdir -p `dirname '$@'`
	install $< $@

clean::
	rm -fr $(BLIB)

distclean purge:: clean
	rm -r Makefile
}

}

sub ufo-inline($filename = 'Makefile', Bool :$alpha) {
    my $binary = $alpha ?? 'alpha' !! 'perl6';
    if $alpha {
        note "Using 'alpha' as the Perl 6 binary. Please upgrade your code.";
    }

    my $sources = get_sources();
    my $scripts = get_scripts();

    my $makefile = $filename eq '-' ?? $*OUT !! open $filename, :w;

    $makefile.print(
        makefile_template()\
            .subst(/^\n/, '')\
            .subst('$binary', $binary)\
            .subst('$sources', $sources)\
            .subst('$scripts', $scripts)
    );
	$makefile.close;
}

sub get_scripts() {
    my $ret = 'SCRIPTS=';
    if 'bin'.IO ~~ :d {
        $ret ~= qx[echo bin/*].chomp;
    }
    return $ret;
}

sub get_sources() {
    return 'SOURCES=' unless 'lib/'.IO ~~ :d;
    # The grep is needed because 'find' prints a final newline, so there'll be an
    # empty-string element at the end of the list.

    my @module-files = grep { $_ },
                    split "\n",
                    qx[find lib -name \*.pm -or -name \*.pm6];

   # To know the best order of compilation, we build a dependency graph of
    # all the modules in lib/. %usages_of ends up containing a graph, with
    # the keys (containing names modules) being nodes, and the values
    # (containing arrays of names) denoting directed edges.

    my @modules = map { path-to-module-name($_) }, @module-files;
    my %usages_of;
    for @module-files -> $module-file {
        my $fh = open($module-file, :r);
        my $module = path-to-module-name($module-file);
        %usages_of{$module} = [];
        for $fh.lines() {
            if /^\s* 'use' \s+ (\w+ ['::' \w+]*)/ && $0 -> $used {
                next if $used eq 'v6';
                next if $used eq 'MONKEY_TYPING';

                %usages_of{$module}.push(~$used);
            }
        }
    }

    my @order = topo-sort(@modules, %usages_of);

    # The intended effect of the below loop is to put as many module paths on
    # each line as possible, breaking when necessary, and indenting nicely.

    my @sources = map { &module-name-to-path($_) }, @order;
    my $sources = 'SOURCES=';
    my $line-length = 0;
    for @sources -> $source {
        $line-length += $source.chars + 1;
        if $line-length > 65 {
                        # SOURCES=
            $sources ~= "\\\n        ";
            $line-length = $source.chars + 1;
        }
        $sources ~= $source ~ ' ';
    }
    $sources.=trim-trailing;
    return $sources;
}

# Internally, we treat the module names as module names, '::' and all.
# But since they're really files externally, they have to be converted
# from paths to module names, and back again.

sub path-to-module-name($path) {
    $path.subst(/^'lib/'/, '').subst(/\.pm6?$/, '').subst('/', '::', :g);
}

sub module-name-to-path($module-name) {
    my $pm = 'lib/' ~ $module-name.subst('::', '/', :g) ~ '.pm';
    $pm.IO ~~ :e ?? $pm !! $pm ~ '6';
}

# According to "Introduction to Algorithms" by Cormen et al., topological
# sort is just a depth-first search of a graph where you pay attention to
# the order in which you get done with a dfs-visit() for each node.

sub topo-sort(@modules, %dependencies) {
    my @order;
    sub dfs-visit($module) {
        %color_of{$module} = 'visited';
        for %dependencies{$module}.list -> $used {
            if %color_of{$used} eq 'not yet visited' {
                dfs-visit($used);
            }
        }
        push @order, $module;
    }

    my %color_of = @modules X=> 'not yet visited';
    for @modules -> $module {
        if %color_of{$module} eq 'not yet visited' {
            dfs-visit($module);
        }
    }
    @order;
}

# vim: ft=perl6
