#!/usr/bin/env perl6
use v6;

my $CONFIGDIR = "%*ENV<HOME>/.neutro";
my $INSTALLDIR = "%*ENV<HOME>/.perl6";
my %modules;

# check if modules list is present, update it otherwise
sub checklist {
	unless $CONFIGDIR.IO ~~ :d {
		mkdirp $CONFIGDIR;
	}
	unless "$CONFIGDIR/modules.list".IO ~~ :f {
		updatedb;
	}
	my $list = slurp "$CONFIGDIR/modules.list";
	my @lines = $list.split("\n");
	for @lines -> $line {
		next if $line ~~ /^\#/;
		my ($name, $protoname, $url) = $line.split: ' ';
		%modules{$name}<protoname> = $protoname;
		%modules{$name}<url> = $url;
	}
}

# translate proto module name to our module name (if needed)
sub getname (Str $name) {
	return $name if %modules.exists($name);
	for %modules.kv -> $module, $data {
		if $data<protoname> eq $name {
			return $module;
		}
	}
	return;
}

sub install (Str $module) {
	my $res;
	my $name = getname $module or die "Unknown module '$module'";
	my $workdir = "$CONFIGDIR/src/$name";
	# getting the module from git
	if $workdir.IO ~~ :e {
		chdir $workdir;
		notice "Updating $name";
		$res = run 'git pull';
		die "Failed updating the repo!" if $res;
	} else {
		mkdirp $workdir;
		chdir $workdir;
		notice "Cloning $name";
		$res = run "git clone %modules{$name}<url> .";
		die "Failed cloning the repo!" if $res;
	}
	# checking if we actually have anything to do
	unless 'lib'.IO ~~ :d {
		die "No lib/, nothing to do"
	}
	# checking and installing dependencies
	if 'deps.proto'.IO ~~ :f {
		my $depfile = slurp 'deps.proto';
		my @deps = $depfile.split: "\n";
		for @deps -> $dep {
			next if $dep ~~ /^\#/;
			next if $dep eq '';
			unless isinstalled $dep {
				my $realdep = getname $dep or die "No such module: $dep ($name dependency)";
				notice "Found $realdep as a $name dependency, installing";
				install $dep;
				notice "$realdep installed, now back into $name";
				chdir $workdir;
			}
		}
	}
	# running tests (if available)
	if 't'.IO ~~ :d {
		notice "Testing $name";
		$res = run 'PERL6LIB=lib:$PERL6LIB prove -e `which perl6` t/';
		die "Tests failed" if $res;
	} else {
		notice "No tests for $name";
	}
	# hardcore installing action
	notice "Installing $name";
	my @targets = dir 'lib';
	chdir 'lib';
	my @modulefiles; # the module files to install
	while @targets {
		my $elem = @targets.shift;
		if $elem.IO ~~ :d {
			for dir($elem) -> $file {
				@targets.push: "$elem/$file";
			}
		}
		if $elem ~~ /\.pm6?$$/ {
			@modulefiles.push: $elem;
		}
	}
	for @modulefiles -> $file {
		my $path = "$INSTALLDIR/lib/" ~ $file;
		my $dir = $path.substr(0, $path.rindex('/'));
		mkdirp $dir;
		run "cp $file $dir";
		say "Installed -> $path";
	}
	notice "Succesfully installed $name";
}

sub isinstalled (Str $module) {
	eval "use $module";
	return $! ?? False !! True;
}

sub listmodules {
	for %modules.keys.sort { .say }
}

sub mkdirp (Str $what) {
	my @parts = $what.split('/').grep: { $_ };
	my $path;
	for @parts -> $dir {
		$path ~= "/$dir";
		next if $path.IO ~~ :e;
		mkdir $path;
	}
}

sub notice (Str $what) {
	say "\e[1m==> ", $what, "\e[0m";
}

sub updatedb {
	notice 'Updating modules database';
	chdir $CONFIGDIR;
	unlink 'modules.list' if 'modules.list'.IO ~~ :e;
	# downloading; TODO: Portable solution
	run 'wget http://github.com/tadzik/neutro/raw/master/modules.list';
	notice 'Fresh modules.list fetched';
}

sub MAIN ($command, $param?) {
	checklist;
	given $command {
		when 'i' {
			unless $param.defined {
				die "i requires a parameter -- a module name";
			}
			install $param;
		}
		when 'l' {
			listmodules;
		}
		when 'u' {
			updatedb;
		}
		default {
			USAGE;
		}
	}
}

sub USAGE {
	say "Usage: neutro <command> [parameter]";
	say "Available commands (with example usage):
	neutro i Acme::Meow -- install Acme::Meow
	neutro l            -- list available modules
	neutro u            -- update the modules database
";
}

# vim: ft=perl6
