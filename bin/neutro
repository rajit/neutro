#!/usr/bin/env perl6
use v6;
use File::Mkdir;
use File::Copy;
use Module::Build;
use Module::Test;
use Module::Install;

my $home = ($*VM<config><osname> eq 'MSWin32')
            ?? %*ENV<HOMEPATH> !! %*ENV<HOME>;
my $CONFIGDIR = "$home/.neutro";
my $INSTALLDIR = %*ENV<DESTDIR> // "$home/.perl6";
my $INSTALLED = "$CONFIGDIR/installed";
my $SRCDIR = "$CONFIGDIR/src";
my $PROJECTS_FILE = 'projects.list';
my %modules;

sub notice (Str $what) {
    say "==> $what";
}

class Git {
    has $!path;
    has $!repository;
    has $!translated_repository;

    method translated_repository {
        unless $!translated_repository {
            $!translated_repository = $!repository.subst: / ^git\:\/\/ /, 'http://';
        }

        return $!translated_repository;
    }

    method pull {
        my $cwd = cwd;
        chdir $!path;
        run 'git pull -q'
            and die "Couldn't pull latest $!path";
        chdir $cwd;
    }

    method clone {
        say "git clone -q { self.translated_repository } $!path";
        run "git clone -q { self.translated_repository } $!path"
            and die "Couldn't clone { self.translated_repository } to $!path"
    }

    method update(Str $url, Str $path) {
        my $git = Git.new(path => $path, repository => $url);

        given $path {
            when .IO.d { $git.pull }
            default { $git.clone }
        }
    }
}

class ModulesDatabase {
    has $!path;
    has $!projects_file;
    has $!ecosystem_source;
    has $!ecosystem_name;
    has $!src_path;

    method update {
        notice "Updating modules database";

        given "$!src_path/$!projects_file" {
            when .IO.e { unlink }
        }

        my $path = self.fetch: $!ecosystem_name, $!ecosystem_source;
        cp "$path/$!projects_file", "$!path/$!projects_file";
    }

    method fetch (Str $name, Str $url) {
        given $!src_path {
            unless .IO.d { mkdir $_, :p }
        }

        notice "Fetching $name";

        my $full_src = "$!src_path/$name";

        Git.update($url, $full_src);

        return $full_src;

        CATCH {
            say $!;
            exit 1;
        }
    }
}

my $db = ModulesDatabase.new(
    path => $CONFIGDIR,
    projects_file => $PROJECTS_FILE,
    ecosystem_source => 'http://github.com/perl6/ecosystem.git',
    ecosystem_name => 'ecosystem',
    src_path => $SRCDIR);

# check if modules list is present, update it otherwise
sub checklist {
    unless $CONFIGDIR.IO ~~ :d {
        mkdir $CONFIGDIR, :p;
    }
    unless "$CONFIGDIR/projects.list".IO ~~ :f {
        $db.update;
    }
    unless $INSTALLED.IO ~~ :f {
        open($INSTALLED, :w).close;
    }
    my $fh = open "$CONFIGDIR/projects.list";
    for $fh.lines -> $line {
        next if $line ~~ /^\#/;
        my ($name, $url) = $line.split: ' ';
        %modules{$name} = $url;
    }
    $fh.close;
}

sub crap (Str $msg) {
    notice $msg;
    exit 1;
}

sub install (Str $module, Bool $strict?, Bool $v?, Bool :$fetch = True) {
    my $res;
    if $fetch {
        %modules.exists($module) or crap "Unknown module $module";
        Git.update: %modules{$module}, "$SRCDIR/$module";
        chdir "$SRCDIR/$module";
    }
    installdeps $module;
    notice "Building $module";
    my $fail = False;
    try {
        Module::Build::build :$v;
        CATCH {
            $fail = True;
        }
    }
    crap "Building $module failed" if $fail;
    # THINKABOUT: what if tests are someplace else?
    # Everyone's allowed to do it
    if $strict and 't'.IO !~~ :d {
        crap "No tests for $module";
    }
    notice "Testing $module";
    try {
        Module::Test::test :$v;
        CATCH {
            $fail = True;
        }
    }
    crap "Tests failed for $module" if $fail;
    notice "Installing $module";
    try {
        Module::Install::install :$v;
        CATCH {
            $fail = True;
        }
    }
    crap "Installing $module failed" if $fail;
    notice "Successfully installed $module";

    unless isinstalled $module {
        given open($INSTALLED, :a) {
            .say($module);
            .close;
        }
    }
}

sub installdeps (Str $name) {
    my $dir = cwd;
    if 'deps.proto'.IO ~~ :f {
        my $fh = open 'deps.proto';
        for $fh.lines -> $dep {
            next if $dep ~~ /^\#/;
            next if $dep eq '';
            unless isinstalled $dep {
                notice "$name depends on $dep, installing now";
                install $dep;
            }
        }
        $fh.close;
    }
    chdir $dir;
}

sub isinstalled (Str $module) {
    my $isit;
    given open($INSTALLED) {
        $isit = .lines.first($module).Bool;
        .close;
    }
    return $isit;
}

sub listmodules {
    for %modules.keys.sort.grep({ $_ }) { .say }
}

multi MAIN ('list') {
    checklist;
    listmodules;
}

multi MAIN ('update') {
    $db.update;
}

multi MAIN ($module, Bool :$strict, Bool :$v) {
    checklist;
    install $module, $strict, $v, :fetch($module eq '.' ?? False !! True);
}

# vim: ft=perl6
